å°†çš„â€œç»“æ„å…ˆéªŒå‹å¤šå±‚å›¾æ¨ç†æ¡†æ¶â€ä¸ GNN-RAG çš„â€œè¯­ä¹‰é©±åŠ¨å¯å­¦ä¹ æ‰©æ•£â€ç»“åˆï¼Œæ„æˆä¸€ä¸ª **â€œç»“æ„å½’çº³å¢å¼ºçš„æ£€ç´¢å¢å¼ºç”Ÿæˆæ¡†æ¶ï¼ˆGNN-RAGÂ³ï¼‰â€**ã€‚ 

**æ ¸å¿ƒæ€æƒ³ï¼š**

* ç”¨ APPR æä¾›ç»“æ„åˆå§‹åŒ–åˆ†å¸ƒï¼ˆå…ˆéªŒï¼‰
* ç”¨ GNN-RAG å­¦ä¹ å›¾ä¸Šä¼ æ’­æœºåˆ¶ï¼ˆå­¦ä¹ ï¼‰
* ç”¨ DDE æ³¨å…¥å‡ ä½•è·ç¦»ä¸æ–¹å‘åç½®ï¼ˆå½’çº³ï¼‰
* ç”¨ PCST å¼ºåŒ–è¾“å‡ºè¿é€šæ€§ä¸è§£é‡Šæ€§ï¼ˆçº¦æŸï¼‰

---

# ä¸€ã€ç³»ç»Ÿæ€»ä½“æ¶æ„ï¼ˆäº”å±‚ç»“æ„ï¼‰

| å±‚çº§  | æ¨¡å—                                  | åŠŸèƒ½                    | å¯¹åº”ä½ /ä»–          |
| --- | ----------------------------------- | --------------------- | -------------- |
| 1ï¸âƒ£ | Text Encoder + Entity Linking       | ä»é—®é¢˜ä¸­æå–è¯­ä¹‰å‘é‡ä¸å®ä½“é›†åˆ       | ä¸¤è€…å…±æœ‰           |
| 2ï¸âƒ£ | Hybrid Retrieval (Embedding + APPR) | å°†è¯­ä¹‰ç›¸ä¼¼ä¸ç»“æ„ç›¸ä¼¼èåˆï¼Œç­›é€‰å€™é€‰å­å›¾   | ä½ çš„æ¨¡å—ï¼ˆæ˜¾å¼ç»“æ„å…ˆéªŒï¼‰   |
| 3ï¸âƒ£ | DDE-Enhanced GNN Propagation        | åŸºäºå¯å­¦ä¹ æ‰©æ•£çš„æ¶ˆæ¯ä¼ é€’ï¼Œå¸¦æ–¹å‘/è·ç¦»åç½® | ç»“åˆï¼ˆä»– + ä½ çš„ DDEï¼‰ |
| 4ï¸âƒ£ | PCST-regularized Evidence Graph     | å¯¹é¢„æµ‹å¾—åˆ†åŠ ç»“æ„åŒ–è¿é€šçº¦æŸï¼Œç”Ÿæˆç´§å‡‘è¯æ®é“¾ | ä½ çš„æ¨¡å—ï¼ˆä¼˜åŒ–è¾“å‡ºï¼‰     |
| 5ï¸âƒ£ | LLM Generation                      | å¯¹è¯æ®è·¯å¾„è¿›è¡Œæ–‡æœ¬åŒ–ç”Ÿæˆç­”æ¡ˆ        | ä»–ï¼ˆä¸‹æ¸¸æ¨ç†ï¼‰        |

---

# äºŒã€æ ¸å¿ƒæœºåˆ¶é€å±‚è¯¦è§£

## ğŸ§© ç¬¬1å±‚ï¼šè¯­ä¹‰ç†è§£ä¸å®ä½“é“¾æ¥

* æ–‡æœ¬ç¼–ç å™¨ï¼šT5 / BERT / RoBERTa
* å– [CLS] / pooled å‘é‡ä¸º (z_q)
* å®ä½“è¯†åˆ«ä¸æ¶ˆæ­§ï¼š

  * NER + å€™é€‰ç”Ÿæˆï¼ˆBM25 / å€™é€‰è¡¨ï¼‰
  * æŒ‰ç½®ä¿¡åº¦å–å‰ k ä¸ªä¸»é¢˜å®ä½“ (T_q)
* è¾“å‡ºï¼š(z_q, T_q)

è¿™éƒ¨åˆ†ä¿æŒä¸€è‡´ï¼›GNN-RAG ä¹Ÿæ˜¯è¿™ä¹ˆåšçš„ã€‚

---

## ğŸ•¸ ç¬¬2å±‚ï¼šHybrid Retrievalï¼ˆAPPR + è¯­ä¹‰åµŒå…¥ï¼‰

### âœ¦ åŸ GNN-RAG åšæ³•ï¼š

é€šè¿‡ dense retriever è®¡ç®—æ–‡æœ¬ç›¸ä¼¼åº¦ï¼Œå†ä»¥å®ä½“ä¸ºç§å­åœ¨å›¾ä¸Šå±•å¼€ï¼Œå½¢æˆå¯†å­å›¾ã€‚
ä¸è¶³ï¼šè¯­ä¹‰æ¼‚ç§»ã€å€™é€‰ä¸ç¨³ã€è®¡ç®—æ˜‚è´µã€‚

### âœ¦ æ”¹è¿›æ–¹æ¡ˆï¼š

å¼•å…¥ **Personalized PageRank (PPR)** æˆ– **APPRï¼ˆApproximate Push-based PPRï¼‰**ï¼š

1. **ç®—æ³•ï¼š**
   [
   p = \alpha (I-(1-\alpha)A)^{-1}p_0
   ]

   * (p_0)ï¼šç§å­åˆ†å¸ƒï¼ˆT_qï¼‰
   * (\alpha)ï¼šé‡å¯ç³»æ•°ï¼ˆ0.85ï¼‰
   * (A)ï¼šé‚»æ¥çŸ©é˜µï¼ˆå…³ç³»å½’ä¸€åŒ–ï¼‰

2. **è¿‘ä¼¼å®ç°ï¼ˆAPPRï¼‰**ï¼š

   * Push-based ç®—æ³•ï¼Œå¤æ‚åº¦ O(|E|Îµâ»Â¹)
   * é€‚ç”¨äºå¤§è§„æ¨¡å›¾ï¼Œç»“æœç¨€ç–

3. **èåˆå¯å­¦ä¹ æƒé‡ï¼š**
   [
   s_v = \sigma(W_1 [,sim_{embed}(z_q, e_v);,PPR_v,] + b)
   ]

   * å…¶ä¸­ (W_1) å­¦ä¹ è¯­ä¹‰ä¸ç»“æ„çš„ç›¸å¯¹æƒé‡
   * è¾“å‡ºæ‰“åˆ† (s_v)ï¼Œå–å‰ Nï¼ˆå¦‚ 1000ï¼‰èŠ‚ç‚¹æ„æˆå€™é€‰å­å›¾ (G_c)

4. **ä½œç”¨ï¼š**

   * ç»™ GNN-RAG çš„ä¼ æ’­é˜¶æ®µæä¾›ç»“æ„è‰¯å¥½çš„åˆå§‹åŒ–åˆ†å¸ƒï¼›
   * é¿å…æ—©æœŸä¼ æ’­è¿›å…¥è¯­ä¹‰ä¸ç›¸å…³åŒºåŸŸã€‚

---

## ğŸ”„ ç¬¬3å±‚ï¼šDDE-Enhanced GNN Propagation

### âœ¦ åŸ GNN-RAG çš„ä¼ æ’­ï¼š

æ¯å±‚ç»´æŠ¤èŠ‚ç‚¹é‡è¦æ€§ (p^{(l)})ï¼Œå¹¶æ ¹æ®é‚»æ¥è¾¹å’Œå…³ç³»æƒé‡ä¼ æ’­ï¼š
[
p^{(l+1)}=(1-\alpha)A_\theta^T p^{(l)}+\alpha p^{(0)}
]

* (A_\theta)ï¼šç”±å…³ç³»æ³¨æ„åŠ›ç”Ÿæˆï¼›
* æ¯å±‚ message ä¾èµ–é—®é¢˜è¯­ä¹‰ (q)ï¼›
* æ¯å±‚ä¼ æ’­åè¿›è¡Œ **é‡å¯æœºåˆ¶ï¼ˆrestartï¼‰**ï¼Œç¡®ä¿å±€éƒ¨ä¿¡æ¯ä¿ç•™ã€‚

### âœ¦ ä½ çš„å¢å¼ºï¼š

åŠ å…¥ **æ–¹å‘-è·ç¦»ç¼–ç  (Directional Distance Encoding, DDE)**ï¼š

1. è®¡ç®—æ¯èŠ‚ç‚¹åˆ°é—®é¢˜å®ä½“çš„è·ç¦» Dist(v)

   * BFS æˆ– Dijkstraï¼ˆåªåœ¨ G_c ä¸Šè¿è¡Œï¼‰ï¼›

2. å®šä¹‰è¾¹ç‰¹å¾ï¼š
   [
   \psi(u,v) = E_h(\min(Dist(u), Dist(v))) + E_d(dir(u,v))
   ]
   å…¶ä¸­ï¼š

   * (E_h)ï¼šå¯å­¦ä¹ è·ç¦»åµŒå…¥ï¼ˆ8â€“64ç»´ï¼‰
   * (E_d)ï¼šæ–¹å‘åµŒå…¥ï¼ˆin/out/selfï¼‰

3. åœ¨ GNN æ¶ˆæ¯ä¼ é€’æ—¶åŠ å…¥ï¼š
   [
   m_{u\to v} = f(h_u, h_v, r_{uv}, \psi(u,v))
   ]

   * (f)ï¼šGAT/GCN/MPNN ç±»å‹
   * ä½¿ä¼ æ’­å—å‡ ä½•çº¦æŸï¼Œæ–¹å‘æ„Ÿä¸è·ç¦»æ„Ÿæ˜¾å¼åŒ–

4. **æ•ˆæœï¼š**

   * é¿å…è¯­ä¹‰ç›¸è¿‘ä½†æ‹“æ‰‘è¿œçš„é”™è¯¯æ‰©æ•£ï¼›
   * å¼ºåŒ–å¤šè·³è·¯å¾„æ¨ç†ï¼›
   * åœ¨ WebQSP / MetaQA 3-hop ä¸Šæå‡æ˜¾è‘—ã€‚

---

## ğŸŒ² ç¬¬4å±‚ï¼šPCSTï¼ˆPrize-Collecting Steiner Treeï¼‰ç»“æ„ä¼˜åŒ–

### âœ¦ åŸ GNN-RAG è¾“å‡ºï¼š

é€‰ Top-K é‡è¦èŠ‚ç‚¹ / ä¸‰å…ƒç»„ï¼ŒæŠ½â€œé—®é¢˜å®ä½“ â†’ ç­”æ¡ˆå®ä½“â€çš„æœ€çŸ­è·¯å¾„ä½œä¸ºè¯æ®ã€‚

### âœ¦ æ”¹è¿›æ–¹æ¡ˆï¼š

ç”¨ PCST å¼ºåŒ–è¿é€šæ€§å’Œç´§å‡‘æ€§ï¼š

1. **é—®é¢˜å½¢å¼åŒ–ï¼š**
   [
   \max_{T\subseteq G_c} \sum_{v\in T} prize(v) - \sum_{e\in T} cost(e)
   ]

   * prize(v)ï¼šèŠ‚ç‚¹é‡è¦æ€§ï¼ˆå¦‚ (p_\theta(v))ï¼‰
   * cost(e)ï¼šè¾¹è·ç¦» / å…³ç³»ä»£ä»·

2. **å¯å¾®å®ç°ï¼ˆè®­ç»ƒæ—¶ï¼‰**

   * ç”¨ Gumbel-sigmoid mask (\pi_e) è¿‘ä¼¼é€‰æ‹©è¾¹ï¼›
   * åŠ ç»“æ„æ­£åˆ™ï¼š
     [
     L_{pcst} = \lambda_1(\text{cost}\cdot\pi) + \lambda_2,\text{ConnPenalty}(\pi) + \lambda_3,\text{SparsityPenalty}(\pi)
     ]
   * ConnPenalty å¯ç”¨å›¾æ‹‰æ™®æ‹‰æ–¯æ­£åˆ™è¿‘ä¼¼ã€‚

3. **æ¨ç†æ—¶**

   * ç”¨è´ªå¿ƒ/è¿‘ä¼¼ç®—æ³•ç”Ÿæˆæœ€ä¼˜è¿é€šå­å›¾ï¼›
   * æ–‡æœ¬åŒ–åè¾“å…¥ LLMã€‚

4. **æ•ˆæœ**

   * å­å›¾æ›´è¿é€šã€å™ªå£°å°‘ï¼›
   * æå‡äº‹å®ä¸€è‡´æ€§ä¸å¯è§£é‡Šæ€§ï¼›
   * å¯ä½œä¸º LLM è¾“å…¥çª—å£å‹ç¼©æœºåˆ¶ã€‚

---

## ğŸ§© ç¬¬5å±‚ï¼šLLM ç”Ÿæˆå±‚ï¼ˆä¸ä»–ä¿æŒä¸€è‡´ï¼‰

* è¾“å…¥ï¼šé—®é¢˜æ–‡æœ¬ + å­å›¾ä¸‰å…ƒç»„ï¼ˆè·¯å¾„æ–‡æœ¬åŒ–ï¼‰ï¼›
* æ¨¡å‹ï¼šLLaMA / T5 / Flanï¼›
* è¾“å‡ºï¼šè‡ªç„¶è¯­è¨€ç­”æ¡ˆï¼›
* å¯é€‰ï¼šç”¨ Self-consistency / Chain-of-Thought æå‡ç¨³å¥æ€§ã€‚

---

# ä¸‰ã€è®­ç»ƒç»†èŠ‚

### æŸå¤±å‡½æ•°

[
L = L_{QA} + \lambda_1 L_{retrieval} + \lambda_2 L_{pcst} + \lambda_3 L_{contrastive}
]

* (L_{QA})ï¼šç­”æ¡ˆç›‘ç£ï¼ˆCE æˆ–èŠ‚ç‚¹åˆ†ç±» + LLM è¾“å‡ºä¸€è‡´æ€§ï¼‰ï¼›
* (L_{retrieval})ï¼šAPPR å¬å›å±‚çš„ pairwise æ’åºæŸå¤±ï¼›
* (L_{pcst})ï¼šç»“æ„æ­£åˆ™ï¼›
* (L_{contrastive})ï¼šè¯­ä¹‰å¯¹æ¯”å­¦ä¹ ï¼ˆq ä¸æ­£ç¡®å®ä½“ embeddingï¼‰ã€‚

### ä¼˜åŒ–ç­–ç•¥

* é¢„çƒ­é˜¶æ®µï¼šå†»ç»“ GNNï¼Œå…ˆè®­ç»ƒ Hybrid å±‚ï¼›
* ç¬¬äºŒé˜¶æ®µï¼šå¯ç”¨ GNN + DDEï¼›
* ç¬¬ä¸‰é˜¶æ®µï¼šå¼•å…¥ PCST è½¯æ­£åˆ™ï¼›
* æœ€ç»ˆé˜¶æ®µï¼šè½»è°ƒ LLM LoRA å¤´ã€‚

---

# å››ã€ç†è®ºå¢å¼ºæœºåˆ¶æ€»ç»“

| æ¨¡å—          | å¯¹æ€§èƒ½çš„ä¸»è¦è´¡çŒ®              |
| ----------- | --------------------- |
| **APPR å±‚**  | æ˜¾å¼ç»“æ„å…ˆéªŒï¼Œä½¿æ£€ç´¢ç¨³å®šã€é«˜å¬å›      |
| **DDE ç¼–ç **  | æä¾›æ–¹å‘ä¸è·ç¦»å½’çº³åç½®ï¼Œæé«˜å¤šè·³æ¨ç†èƒ½åŠ›  |
| **PCST çº¦æŸ** | æå‡è¯æ®é“¾è¿é€šæ€§ã€å‡å°‘å†—ä½™ã€å¢å¼ºè§£é‡Šæ€§   |
| **èåˆè®­ç»ƒ**    | ä¿æŒæ¢¯åº¦å¯é€šï¼Œç«¯åˆ°ç«¯ä¼˜åŒ–ç»“æ„-è¯­ä¹‰è”åˆè¡¨ç¤º |

ç†è®ºæå‡æ¥æºï¼š

1. **æ›´ç¨³çš„åˆå§‹åˆ†å¸ƒ** â†’ å‡å°‘é”™è¯¯æ‰©æ•£ï¼›
2. **å‡ ä½•æ„ŸçŸ¥ä¼ æ’­** â†’ å¼ºåŒ–è¿œç¨‹ä¾èµ–æ•æ‰ï¼›
3. **ç»“æ„æ­£åˆ™** â†’ æé«˜ç»“æœä¸€è‡´æ€§ä¸å¯è§£é‡Šæ€§ã€‚

---

# äº”ã€é¢„æœŸæ€§èƒ½ï¼ˆå‚è€ƒ WebQSPï¼‰

| æ¨¡å‹                           | Acc        | è§£é‡Šæ€§ |
| ---------------------------- | ---------- | --- |
| SubgraphRAG                  | 73         | å¼±   |
| GNN-RAG                      | 90         | ä¸€èˆ¬  |
| GNN-RAGÂ³ (APPR + DDE + PCST) | **94â€“95+** | å¼º   |

---

# ğŸ§© å…­ã€æ ¸å¿ƒé€»è¾‘ä¸€å¥è¯æ€»ç»“

> GNN-RAG å­¦çš„æ˜¯ â€œå¦‚ä½•åœ¨å›¾ä¸Šä¼ æ’­è¯­ä¹‰â€ï¼›
> ä½ æä¾›çš„æ˜¯ â€œå›¾è¯¥ä»å“ªé‡Œå¼€å§‹ä¼ æ’­ã€ä¼ æ’­è¯¥å—å“ªäº›å‡ ä½•çº¦æŸã€ç»“æœè¯¥è¿æˆä»€ä¹ˆæ ·â€ã€‚

ä¸¤è€…åˆä½“åï¼Œä¿¡æ¯æµå˜æˆï¼š
[
\text{è¯­ä¹‰é—®é¢˜} \Rightarrow \text{ç»“æ„å…ˆéªŒ (APPR)} \Rightarrow \text{å‡ ä½•ä¼ æ’­ (DDE+GNN)} \Rightarrow \text{ç»“æ„ä¼˜åŒ– (PCST)} \Rightarrow \text{ç”Ÿæˆ (LLM)}
å’Œä¼ªä»£ç å¥½ï¼Œç»™ä½ ä¸€å¥—**å¯ç›´æ¥ç…§ç€å®ç°**çš„ä¼ªä»£ç ï¼ˆè®­ç»ƒ + æ¨ç† + è·¯ç”±ï¼‰ï¼ŒæŠŠä½ çš„ APPR/DDE/PCST å’Œè®ºæ–‡é‡Œçš„ GNN-RAG ä¸»å¹²æ— ç¼æ‹¼å¥½ã€‚å˜é‡åå°½é‡å·¥ç¨‹åŒ–ã€å¯è½åœ°ã€‚æ–‡æœ«ç»™å…³é”®æœºåˆ¶å‡ºå¤„ã€‚

---

## 0) é…ç½®ä¸æ•°æ®ç»“æ„

```pseudo
# === Hyper params ===
L = 6                         # GNN å±‚æ•°ï¼ˆä¸­é€”é‡å¯ç”¨å¶æ•°ï¼‰  [è®ºæ–‡]
K = 3                         # é—®é¢˜å¤šå¤´è¯­ä¹‰
EMB_DIM = 256                 # èŠ‚ç‚¹/å…³ç³»éšå±‚
HOP_EMB_DIM = 16              # DDE è·ç¦»åµŒå…¥ç»´åº¦
DIR_EMB_DIM = 8               # DDE æ–¹å‘åµŒå…¥ç»´åº¦
ALPHA_PPR = 0.85              # APPR é‡å¯ç³»æ•°ï¼ˆç»“æ„å…ˆéªŒï¼‰
TOPN_CAND = 1200              # å€™é€‰å­å›¾èŠ‚ç‚¹æ•°ä¸Šé™
CUM_PROB_TH = 0.95            # ç´¯è®¡æ¦‚ç‡é˜ˆå€¼ï¼ˆç­›å€™é€‰ç­”æ¡ˆï¼‰  [è®ºæ–‡]
PCST_LAMBDA = (0.1, 0.1, 0.05)# (cost, connectivity, sparsity) æƒé‡
EDGE_TEMP = 2.0               # Gumbel-Sigmoid åˆå§‹æ¸©åº¦

# === Inputs ===
q: string                   # é—®é¢˜
KG: (V, E, R)               # çŸ¥è¯†å›¾è°±
Docs: optional              # è‹¥éœ€é•¿ä¸Šä¸‹æ–‡æ£€ç´¢

# === Outputs ===
ans: list[str]              # ç­”æ¡ˆ
evidence_paths: list[path]  # è¯æ®è·¯å¾„ï¼ˆæ–‡æœ¬åŒ–ï¼‰
```

---

## 1) å‰ç½®æ¨¡å—

```pseudo
function TEXT_ENCODER(q) -> z_q:
    # Transformer ç¼–ç å™¨ (BERT/T5/RoBERTa)
    return pooled_cls(q)

function ENTITY_LINK(q) -> T_q:
    # NER + å€™é€‰æ£€ç´¢ + æ¶ˆæ­§ï¼ˆä½ å·²æœ‰å®ç°ï¼‰
    return [entities...]

function APPR(KG, seeds=T_q, alpha=ALPHA_PPR, tol=1e-6) -> appr_score:
    # Push-based Approximate PPRï¼Œè¿”å›æ¯ä¸ªèŠ‚ç‚¹çš„ç»“æ„ç›¸å…³åº¦
    return dict(node_id -> score)

function SEM_SIM(z_q, V) -> sem_score:
    # z_q ä¸èŠ‚ç‚¹/åˆ«ååµŒå…¥çš„è¯­ä¹‰ç›¸ä¼¼åº¦ï¼ˆdense retrieverï¼‰
    return dict(node_id -> score)

function HYBRID_RETRIEVAL(sem_score, appr_score, z_q) -> cand_nodes:
    alpha_q = sigmoid(W_alpha @ z_q)     # å¯å­¦ä¹ æƒé‡ï¼ˆæ ‡é‡æˆ–å°å‘é‡ï¼‰
    s_v = alpha_q * appr_score[v] + (1 - alpha_q) * sem_score[v] + b
    cand_nodes = topN_by_score(s_v, N=TOPN_CAND)
    return cand_nodes
```

---

## 2) å€™é€‰å­å›¾ä¸è·ç¦»ç¼–ç ï¼ˆDDEï¼‰

```pseudo
function BUILD_CAND_SUBGRAPH(KG, cand_nodes) -> G_c:
    # å–å­å›¾ï¼šcand_nodes è¯±å¯¼çš„èŠ‚ç‚¹ + å…¶é—´çš„è¾¹ï¼ˆåŒ…å«å…³ç³»ç±»å‹ï¼‰
    return subgraph

function DIST_TO_SEEDS(G_c, T_q) -> Dist:
    # ä»…åœ¨ G_c ä¸Šè·‘è·ç¦»ï¼Œçœè®¡ç®—
    # è‹¥è¾¹ç­‰æƒï¼šBFSï¼›éè´Ÿæƒï¼šDijkstraã€‚è¶…å¤§ç¨€ç–ï¼šBMSSP
    return dict(node -> hop_dist)

function DDE_EDGE_FEAT(G_c, Dist) -> edge_feat:
    for e = (u -> v) in G_c.E:
        h = min(Dist[u], Dist[v])
        dir = direction(u, v)  # in/out/self
        dde = EmbHop(h) âŠ• EmbDir(dir)   # learnable
        edge_feat[e] = dde
    return edge_feat
```

---

## 3) GNN-RAG ä¸»å¹²ï¼ˆå¸¦ä¸­é€”é‡å¯ï¼‰+ ä½ çš„ DDE èåˆ

```pseudo
function Q_HEADS(z_q, K) -> [q_k]:
    # å°†é—®é¢˜è¯­ä¹‰åˆ†è§£ä¸º K ä¸ªå¤´ï¼ˆattention poolingï¼‰
    return [q_1, ..., q_K]

function REL_EMB(relation) -> r_emb:
    # å…³ç³»æ–‡æœ¬ -> LM ç¼–ç  -> å– CLS/æŠ•å½±
    return r_emb

function MESSAGE(u, v, r, q_k, dde) -> m_u2v:
    # è®ºæ–‡é‡ŒåŸºäº (q_k âŠ™ r) çš„ç›¸å…³æ€§é—¨æ§  Ã—  ä½ çš„ DDE å‡ ä½•é—¨æ§
    gate_rel = sigma(q_k âŠ™ r)
    gate_geo = MLP_dde(dde)              # æˆ– sigmoid/softplus
    return gate_rel âŠ™ gate_geo âŠ™ W_msg @ h_u

function GNN_PROPAGATE(G_c, T_q, z_q, L, K, edge_feat) -> (H, pL):
    init:
        H^(0)[v] = node_init(v)          # å¯å«åˆ«å/ç±»å‹åµŒå…¥
        p^(0)[v] = 1 if v âˆˆ T_q else 0   # ç§å­æ¦‚ç‡
        q_heads = Q_HEADS(z_q, K)

    for l in 0..L-1:
        # æ¶ˆæ¯æ±‡èšï¼ˆå¤šå¤´ï¼‰
        for v in G_c.V:
            agg = []
            for k in 1..K:
                sum_k = 0
                for (u -> v, r) in N_in(v):
                    r_emb = REL_EMB(r)
                    dde = edge_feat[(u->v)]
                    m = MESSAGE(u, v, r_emb, q_heads[k], dde)
                    sum_k += p^(l)[u] * m
                agg.append(sum_k)
            H_tmp[v] = MLP_cat([H^(l)[v]] âŠ• concat(agg))   # Ïˆ(Â·)

        # èŠ‚ç‚¹é‡è¦åº¦æ›´æ–° + å½’ä¸€åŒ–
        for v: s[v] = H_tmp[v] Â· w_learnable
        p^(l+1) = softmax(s)      # æ¦‚ç‡åˆ†å¸ƒï¼Œæ³¨æ„æ•°å€¼ç¨³å®š

        # ä¸­é€”é‡å¯ï¼ˆå…³é”®ï¼ï¼‰
        if l == L/2 - 1:
            p^(l+1) = p^(0)      # é‡å¯å›ç§å­ï¼Œé¿å…æ‰©æ•£æ¼‚ç§»   [è®ºæ–‡]

        H^(l+1) = H_tmp

    return H^(L), p^(L)
```

---

## 4) ç­›å€™é€‰ç­”æ¡ˆã€æŠ½æœ€çŸ­è·¯å¹¶æ–‡æœ¬åŒ–ï¼ˆé€ LLMï¼‰

```pseudo
function SELECT_ANS_CAND(pL, threshold=CUM_PROB_TH) -> A_cand:
    # æŒ‰ pL ä»é«˜åˆ°ä½ç´¯åŠ ï¼Œç›´åˆ°ç´¯è®¡æ¦‚ç‡ â‰¥ 0.95    [è®ºæ–‡]
    return top_set

function SHORTEST_PATHS(G_c, T_q, A_cand) -> paths:
    # å¯¹æ¯ä¸ªå€™é€‰ç­”æ¡ˆ a âˆˆ A_cand ï¼Œæ‰¾ T_q åˆ° a çš„æœ€çŸ­è·¯å¾„
    # å¯å¤šæ¡ï¼Œé™åˆ¶æ¡æ•°ä¸é•¿åº¦
    return list_of_paths

function VERBALIZE(paths) -> knowledge_text:
    # å°†ä¸‰å…ƒç»„/è·¯å¾„æ¨¡æ¿åŒ–ï¼Œæ‹¼å‡º â€œKnowledge: ... \n Question: ...â€
    return str
```

---

## 5) PCST ç»“æ„åŒ–è¯æ®ï¼ˆè’¸é¦ + è½¯çº¦æŸï¼‰

```pseudo
# --- é˜¶æ®µAï¼šPCST åå¤„ç†è’¸é¦ï¼ˆå…ˆæ˜“åéš¾ï¼‰ ---
function PCST_APPROX(G_c, node_prize, edge_cost) -> G_hat:
    # Goemans/Williamson è¿‘ä¼¼æˆ–è´ªå¿ƒ
    return subgraph_mask (nodes/edges)

function EDGE_SELECTOR(scores) -> pi_soft:
    # å­¦ä¸€ä¸ªè¾¹é€‰æ‹©å¤´ï¼špi_e = sigmoid(W_edge @ score_e)
    return dict(edge -> prob)

# è®­ç»ƒæ—¶ï¼š
G_hat = PCST_APPROX(G_c,
        prize = Î± * APPR_score + (1-Î±) * node_score_from_pL,
        cost  = Î² * dist(edge) + Î³ * relation_cost(edge.rel))
pi_soft = EDGE_SELECTOR(edge_scores_from_GNN)
L_pcst_distill = BCE(pi_soft, mask(G_hat))

# --- é˜¶æ®µBï¼šå¯å¾®è½¯çº¦æŸï¼ˆè”è®­ï¼‰ ---
function PCST_SOFT_REG(pi_soft, cost, Laplacian) -> L_pcst:
    conn = pi_soft^T * Laplacian * pi_soft          # è¿é€šæ€§è¿‘ä¼¼
    sparse = L1(pi_soft)                             # ç¨€ç–æƒ©ç½š
    return Î»1 * (cost Â· pi_soft).sum() + Î»2 * conn + Î»3 * sparse
```

---

## 6) LLM ç«¯ç”Ÿæˆ

```pseudo
function LLM_GENERATE(knowledge_text, q) -> answers:
    # LLaMA/Flanï¼Œæˆ–è½»é‡ LoRA
    return decode_answers()

# è‹¥åšè”åˆè°ƒä¼˜ï¼šæœ€å°åŒ– L_QAï¼ˆç­”æ¡ˆäº¤å‰ç†µ / span F1ï¼‰
```

---

## 7) è®­ç»ƒä¸»å¾ªç¯ï¼ˆå››é˜¶æ®µæ—¥ç¨‹ï¼Œç¨³å®šæ”¶æ•›ï¼‰

```pseudo
for step in 1..MAX_STEPS:

    # === (1) å‰å‘ ===
    z_q = TEXT_ENCODER(q)
    T_q = ENTITY_LINK(q)

    sem = SEM_SIM(z_q, KG.V)
    appr = APPR(KG, T_q, alpha=ALPHA_PPR)
    cand_nodes = HYBRID_RETRIEVAL(sem, appr, z_q)
    G_c = BUILD_CAND_SUBGRAPH(KG, cand_nodes)

    Dist = DIST_TO_SEEDS(G_c, T_q)
    edge_feat = DDE_EDGE_FEAT(G_c, Dist)

    H, pL = GNN_PROPAGATE(G_c, T_q, z_q, L, K, edge_feat)
    A_cand = SELECT_ANS_CAND(pL, CUM_PROB_TH)    # 0.95 [è®ºæ–‡]
    paths = SHORTEST_PATHS(G_c, T_q, A_cand)
    knowledge = VERBALIZE(paths)

    pred_answers = LLM_GENERATE(knowledge, q)

    # === (2) æŸå¤± ===
    L_QA = QA_LOSS(pred_answers, gold_answers)
    L_ret = RETRIEVAL_RANKING_LOSS(cand_nodes, gold_neighbors)    # pairwise
    L_con = CONTRASTIVE(z_q, pos_entities, neg_entities)
    # PCST è’¸é¦/è½¯çº¦æŸæŒ‰æ—¥ç¨‹åˆ†é˜¶æ®µå¼€å¯
    if STAGE >= A:
        L_pcst_distill = BCE(EDGE_SELECTOR(...), mask_from_PCST(...))
    if STAGE >= B:
        L_pcst = PCST_SOFT_REG(pi_soft, cost=edge_cost, Laplacian=L_g)

    total_loss = L_QA + Î»_r*L_ret + Î»_c*L_con + Î»_p*(L_pcst + L_pcst_distill)

    # === (3) åä¼ ä¸ä¼˜åŒ– ===
    total_loss.backward()
    optimizer.step(); optimizer.zero_grad()

    # === (4) æ¸©åº¦ä¸æƒé‡è°ƒåº¦ ===
    EDGE_TEMP = schedule(EDGE_TEMP)   # 2.0 â†’ 0.5ï¼ˆé€€ç«ï¼‰
```

**è®­ç»ƒæ—¥ç¨‹å»ºè®®**

* Warm-up 5kï¼šå†» GNNï¼Œåªè®­ HYBRID (W_alpha) + EL é‡æ’
* Joint-1 20kï¼šå¼€ GNN + DDEï¼ˆä¸å¼€ PCSTï¼‰ï¼ŒÎ»_r=0.1
* Distill 10kï¼šåŠ  L_pcst_distillï¼ŒÎ»_p=0.1
* Joint-2 20kï¼šåŠ è½¯çº¦æŸ L_pcstï¼ŒÎ»_p=0.2ï¼›æ§åˆ¶æ¢¯åº¦ä¸æ¸©åº¦
* LLM ç«¯ï¼šä»… LoRAï¼ˆr=16, Î±=32ï¼‰ï¼Œlr å°ï¼ˆ5e-5ï¼‰

---

## 8) æ¨ç†ï¼ˆæ— æ¢¯åº¦ï¼‰

```pseudo
function INFER(q):
    z_q = TEXT_ENCODER(q)
    T_q = ENTITY_LINK(q)

    sem = SEM_SIM(z_q, KG.V); appr = APPR(KG, T_q)
    cand_nodes = HYBRID_RETRIEVAL(sem, appr, z_q)
    G_c = BUILD_CAND_SUBGRAPH(KG, cand_nodes)

    Dist = DIST_TO_SEEDS(G_c, T_q)
    edge_feat = DDE_EDGE_FEAT(G_c, Dist)

    H, pL = GNN_PROPAGATE(G_c, T_q, z_q, L, K, edge_feat)
    A_cand = SELECT_ANS_CAND(pL, 0.95)                      # [è®ºæ–‡]
    paths = SHORTEST_PATHS(G_c, T_q, A_cand)
    knowledge = VERBALIZE(paths)

    answers = LLM_GENERATE(knowledge, q)
    return answers, paths
```

---

## 9) ä¸é•¿ä¸Šä¸‹æ–‡æ£€ç´¢çš„è·¯ç”±ï¼ˆGNN-RAG+Routeï¼‰

```pseudo
function ROUTE(q):
    ans_gnn, paths_gnn = INFER(q)            # æ·±å›¾ä¸Šä¸‹æ–‡è·¯å¾„
    # æ–‡æœ¬åµŒå…¥æ£€ç´¢ï¼ˆSubgraphRAGï¼‰ï¼Œå– top-k=100 ä¸‰å…ƒç»„  [è®ºæ–‡]
    triples_long = TEXT_EMBED_RETRIEVE(q, k=100)

    if any(answer âˆ‰ entities(triples_long) for answer in ans_gnn):
        # è¯´æ˜ GNN-RAG ç»™å‡ºäº†â€œé•¿ä¸Šä¸‹æ–‡æœªè¦†ç›–â€çš„æ·±å±‚å›¾è¯æ® â†’ èµ° GNN è·¯å¾„
        return ans_gnn, paths_gnn
    else:
        # è¯­ä¹‰æ£€ç´¢å·²è¦†ç›–ç­”æ¡ˆ â†’ èµ°é•¿ä¸Šä¸‹æ–‡ï¼ˆæ›´å¤§å…¨å±€è¯æ®ï¼‰
        ans_lc = LONG_CONTEXT_LLM(q, triples_long)
        return ans_lc, triples_long
```

---

## å…³é”®æœºåˆ¶ä¸å‚æ•°å‡ºå¤„ï¼ˆè®ºæ–‡é¡µç /è¡Œå·ï¼‰

* æ·±å±‚ GNN ä¼ æ’­ã€èŠ‚ç‚¹é‡è¦åº¦ softmaxã€**L/2 é‡å¯**æœºåˆ¶ä¸é»˜è®¤ **L=6**ï¼š

* è®­ç»ƒæ—¶èŠ‚ç‚¹åˆ†ç±»ï¼ˆç­”æ¡ˆ=1ï¼‰ï¼Œ**ç´¯è®¡æ¦‚ç‡â‰¥0.95** é€‰å€™é€‰ç­”æ¡ˆï¼ŒæŠ½ **æœ€çŸ­è·¯å¾„** æ–‡æœ¬åŒ–ä½œä¸º LLM ä¸Šä¸‹æ–‡ï¼š

* GNN-RAG å…ˆâ€œGNN å–å€™é€‰ç­”æ¡ˆâ†’æœ€çŸ­è·¯â†’æ–‡æœ¬åŒ–â†’LLMâ€ï¼Œå¼ºè°ƒâ€œæ·±å›¾ä¸Šä¸‹æ–‡â€ï¼š

* GNN-RAG+Routeï¼šä¸ **SubgraphRAG** çš„ **top-k=100** é•¿ä¸Šä¸‹æ–‡å¯¹æ¯”ã€**ä¸é‡å å³è·¯ç”±åˆ° GNN**ï¼š





          
ä¸æ˜¯çš„ï¼Œ`train_gnn_rag.py` è„šæœ¬ç»“æŸå**ä¸ä¼šç›´æ¥ç”ŸæˆåŒ…å«å€™é€‰å®ä½“æ’åºã€æ¨ç†è·¯å¾„å’Œè¯æ®å­å›¾çš„.infoæ–‡ä»¶**ã€‚

è®©æˆ‘è¯¦ç»†è§£é‡Šä¸€ä¸‹å®Œæ•´çš„æµç¨‹ï¼š

## 1. `train_gnn_rag.py` çš„è¾“å‡º

è¿™ä¸ªè„šæœ¬åªè´Ÿè´£**è®­ç»ƒGNNæ¨¡å‹**ï¼Œè®­ç»ƒå®Œæˆåä¼šç”Ÿæˆï¼š
- è®­ç»ƒå¥½çš„æ¨¡å‹æ£€æŸ¥ç‚¹æ–‡ä»¶ï¼ˆå¦‚ `joint2_best.pt`ï¼‰
- è®­ç»ƒæ—¥å¿—æ–‡ä»¶
- åŸºæœ¬çš„è¯„ä¼°æŒ‡æ ‡ï¼ˆä¿å­˜åœ¨ `final_results.json`ï¼‰

ä½†**ä¸ä¼šç”Ÿæˆ.infoæ–‡ä»¶**ã€‚

## 2. ç”Ÿæˆ.infoæ–‡ä»¶éœ€è¦é¢å¤–çš„è¯„ä¼°æ­¥éª¤

è¦ç”ŸæˆåŒ…å«è¯¦ç»†æ¨ç†ä¿¡æ¯çš„.infoæ–‡ä»¶ï¼Œéœ€è¦åœ¨è®­ç»ƒå®Œæˆå**å•ç‹¬è¿è¡Œè¯„ä¼°**ï¼š
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\GNN-RAG-main\gnn\README.md
          
## 3. æ­£ç¡®çš„ç”Ÿæˆ.infoæ–‡ä»¶æµç¨‹

### æ­¥éª¤1ï¼šè®­ç»ƒGNNæ¨¡å‹
```bash
python train_gnn_rag.py --dataset webqsp --gpu 0
```
è¿™ä¼šç”Ÿæˆè®­ç»ƒå¥½çš„æ¨¡å‹æ£€æŸ¥ç‚¹ã€‚

### æ­¥éª¤2ï¼šè¿è¡Œè¯„ä¼°ç”Ÿæˆ.infoæ–‡ä»¶
è®­ç»ƒå®Œæˆåï¼Œéœ€è¦å•ç‹¬è¿è¡Œè¯„ä¼°å‘½ä»¤ï¼š

```bash
cd gnn
python main.py ReaRev --is_eval \
    --load_experiment joint2_best.pt \
    --entity_dim 50 \
    --num_epoch 200 \
    --batch_size 8 \
    --eval_every 2 \
    --data_folder data/webqsp/ \
    --lm sbert \
    --num_iter 3 \
    --num_ins 2 \
    --num_gnn 3 \
    --relation_word_emb True \
    --name webqsp \
    --use_appr --appr_alpha 0.85 --cand_n 1200 \
    --use_dde --hop_dim 16 --dir_dim 8 \
    --use_pcst --pcst_lambda 0.1,0.1,0.05 \
    --mid_restart
```

### æ­¥éª¤3ï¼šç§»åŠ¨.infoæ–‡ä»¶ä¾›LLMä½¿ç”¨
è¯„ä¼°å®Œæˆåï¼Œä¼šåœ¨GNNçš„è¾“å‡ºç›®å½•ç”Ÿæˆ `{experiment_name}_test.info` æ–‡ä»¶ï¼Œç„¶åéœ€è¦ï¼š

```bash
# å°†.infoæ–‡ä»¶ç§»åŠ¨åˆ°LLMæ¨¡å—
cp gnn/outputs/gnn_rag3_webqsp/{experiment_name}_test.info llm/results/gnn/test.info
```

## 4. å®Œæ•´çš„GNN-RAGÂ³æ¨ç†æµç¨‹

æœ€åï¼Œä½¿ç”¨LLMè¿›è¡Œæ¨ç†ï¼š
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\GNN-RAG-main\llm\scripts\rag-reasoning.sh
          
ä»è„šæœ¬å¯ä»¥çœ‹åˆ°ï¼ŒLLMæ¨ç†æ—¶ä¼šè¯»å– `results/gnn/${DATA_NAME}/rearev-sbert/test.info` æ–‡ä»¶ä½œä¸ºè¾“å…¥ã€‚

## æ€»ç»“

**`train_gnn_rag.py` è„šæœ¬ç»“æŸåä¸ä¼šç›´æ¥ç”Ÿæˆ.infoæ–‡ä»¶**ã€‚å®Œæ•´æµç¨‹æ˜¯ï¼š

1. **è®­ç»ƒé˜¶æ®µ**ï¼š`train_gnn_rag.py` â†’ ç”Ÿæˆè®­ç»ƒå¥½çš„GNNæ¨¡å‹
2. **è¯„ä¼°é˜¶æ®µ**ï¼šè¿è¡Œ `python main.py --is_eval` â†’ ç”ŸæˆåŒ…å«æ¨ç†è·¯å¾„çš„.infoæ–‡ä»¶  
3. **æ¨ç†é˜¶æ®µ**ï¼šè¿è¡Œ `llm/scripts/rag-reasoning.sh` â†’ LLMä½¿ç”¨.infoæ–‡ä»¶è¿›è¡Œæœ€ç»ˆæ¨ç†

.infoæ–‡ä»¶æ˜¯åœ¨ç¬¬2æ­¥çš„è¯„ä¼°é˜¶æ®µç”Ÿæˆçš„ï¼ŒåŒ…å«äº†ï¼š
- å€™é€‰å®ä½“æ’åºï¼ˆ`cand`å­—æ®µï¼‰
- æ¨ç†è·¯å¾„ï¼ˆæ¯æ­¥çš„`rel_action`ï¼‰
- è¯„ä¼°æŒ‡æ ‡ï¼ˆprecision, recall, f1ç­‰ï¼‰

è¿™ä¸ªæ–‡ä»¶æ˜¯è¿æ¥GNNæ¨ç†å’ŒLLMç”Ÿæˆçš„å…³é”®æ¡¥æ¢ã€‚
        